#! /usr/bin/env zsh

# assorted git functions

# move forward linearly a given number of commits
gforw() {
  git checkout \
    $(git rev-list --topo-order HEAD..${2:-master} | tail -$1 | head -1)
}

# move back linearly a given number of commits
gback() { git checkout HEAD~$1 }

# make a quick fix at a previous commit
# currently assuming if user enters number > 50 (or gives an alphanumeric
# value) that they want to jump to a commit hash
# known issue - inaccurate comparisons for parameters beginning with `0`
# e.g. `gfix 0759` will print out an error as `(( 0759 < 50 ))` exits with a 0
# the function still works as the failure of gback triggers execution after ||
gfix() {
  # attempt to delete `fix` branch if it exists
  if git rev-parse --quiet --verify fix > /dev/null 2>&1; then
    git branch -d fix || {
      # if deletion fails, echo reason then return with exit code
      maybe_err=$?
      echo 'Deletion of `fix` branch failed, delete it manually then try again'
      return $maybe_err
    }
  fi

  # checkout out # commits back or specific hash depending on user input
  # <-> matches any number of digits
  { { [[ $1 = <-> ]] && (( $1 < 50 )) } && gback "$1" || git checkout "$1" } || {
    maybe_err=$?
    echo 'Checkout failed, please fix the error then try again'
    return $maybe_err
  }

  git checkout -b fix
}

# rebase given branch on fix branch
gffix() {
  # abort if no branch given
  git rev-parse --quiet --verify "$1" > /dev/null 2>&1 || {
    maybe_err=$?
    echo "Sorry, that branch doesn't seem to exist"
    return $maybe_err
  }

  # abort if there are unstaged changes as this will cause rebase to fail
  git diff-index --quiet HEAD -- || {
    maybe_err=$?
    echo 'You have unstaged changes, stash or commit them, then run again'
    return $maybe_err
  }

  # checkout branch to rebase on fix
  git checkout "$1" || {
    maybe_err=$?
    echo 'Checkout failed, please fix the error then try again'
    return $maybe_err
  }

  # should not fail due to untracked changes as we checked previously
  git rebase -i fix
  # deletes branch regardless of merge conflicts during interactive rebase
  git branch -d fix
}

# delete given branch locally & remotely
gdel() {
  [[ -z $1 ]] && {
    echo 'No branch given, aborting'
    return 1
  }

  # `$@` holds all arguments
  git branch -D $@
  git push origin -d $@
}

# add directory except given files/directories
gae() {
  git add .
  git reset -- $@
}

# `cd` to repo root if in a git repo
cdrr() { cd $(rr) }

# force pull tracking branch & reset to `origin/$1`
# passing a branch that is not a tracking of the checked out local branch will
# work though may be unintuitive
gpuf() {
  [[ -z $1 ]] && echo 'No branch given, aborting' && return 1

  # only reset if we can't fastfforward
  git pull --all || git reset --hard "origin/$1"
}

# creates a commit w/ given message (default `wip`) with all changes starting at
# root. similar to `git stash`, except adds untracked files
# mnemonic - `git commit wip`
gcw() {
  # add all changes starting at root
  git add "$(git rev-parse --show-toplevel)"
  git commit -m "${1:-wip}"
}

# creates a commit w/ given message (default `wip`) with all changes to tracked
# files starting at root. similar to `git stash`
# mnemonic - `git commit wip tracked`
gcwt() {
  # add any tracked files starting at root
  git add -u "$(git rev-parse --show-toplevel)"
  git commit -m wip
}
