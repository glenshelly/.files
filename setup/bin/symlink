#! /usr/bin/env bash

# <<<< motivation/design doc >>>>
#
# see writeup of motivation & methodology @ $DOTFILES/setup/symlink.md

# note: values returned by setting variables, usually namespaced with `_`. for
# scoping purposes, the calling function should define local variables with the
# expected name. that is, if your function is named `foo` and returns in the
# variable `_ret_val`, your calling function should look something like this:
#
# ```
# # define local to hold return value
# local _ret_val
# ... # whatever code your heart desires (don't shadow `_ret_val`)
# # call function
# foo
# # use `_ret_val` with returned value
# echo $_ret_val
# ```

source "$DOTFILES/setup/lib/prompts.sh"
source "$DOTFILES/setup/lib/util.sh"

# perform symlinking according to scheme specified in design doc (path -
# `$DOTFILES/setup/symlink.md`)
symlink() {
  header "<< Symlinking >>\nfollowing scheme detailed @\
 $DOTFILES/setup/symlink.md"

  local overwrite_all=false backup_all=false skip_all=false

  # write all files within depth w/ `.symlink` in their name, excluding `.git` &
  # `submodules` directories
  for src in $( \
    find \
      -H "$DOTFILES" \
      -maxdepth 3 \
      -name '*.symlink*' \
      -not -path '*.git/*' \
      -not -path '*/submodules/*' \
  )
  do
    filename=$(basename $src)

    local path_components='([-._a-zA-Z]+~)*'
    local name='[-._a-zA-Z]+'
    local flags='[_d]{1,2}'
    local _symlink_regex="^($path_components)($name)\.symlink(\.$flags)?$"

    [[ $filename =~ $_symlink_regex ]] && {
      _symlink_based_on_filename "$src" "$filename"
    } || {
      info "skipped symlinking $filename (contains \`.symlink\` but doesn't \
match symlinking syntax)"
    }
  done
}

check_regex() {
  local path_components='([-._a-zA-Z]+~)*'
  local name='[-._a-zA-Z]+'
  local flags='[_d]{1,2}'
  local _symlink_regex="^($path_components)($name)\.symlink(\.$flags)?$"

  filename=$(basename $1)
  [[ $filename =~ $_symlink_regex ]] && {
    echo "valid - $filename"
    _symlink_based_on_filename $filename $1
  } || {
    info "skipped symlinking file w/ invalid syntax - $filename"
  }
}

# symlink individual file/directory based on name
#
# Args:
#   - {string} src - path to source file
#   - {string} filename - filename of source file
_symlink_based_on_filename() {
  local src=$1 filename=$2
  local _path='' _name='' _direct=false _unhidden=false

  # extract target name and optional path from target filename
  _extract_path "$filename"
  _extract_name "$filename"

  # extract and check values of each possible flag
  _check_flags "$filename"

  # debugging
  echo ''
  echo "src, source filename <> $src, $filename"
  echo "target name; path; flags (direct, unhidden) <> $_name; $_path; \
($_direct, $_unhidden)"

  # check if `src` is a directory
  # ref - https://www.tldp.org/LDP/abs/html/fto.html
  if [[ -d "$src" ]]; then
    if [[ $direct == true ]]; then
      local maybe_dot="$([[ $_unhidden != true ]] && echo '.')"
      # if `_path` is empty, keep '', else append '/'
      local maybe_path="$([[ ! -z $_path ]] && echo "$_path/")"

      # relative path from home, w/ or w/o `.` based on `_unhidden`
      local dst="$HOME/${maybe_path}${maybe_dot}${_name}"

      link_file "$src" "$dst"
    else
      info 'in future handle non-direct case'
    fi
  else
    if [[ $_direct == true ]]; then
      warn "Invalid flag \`d\` (direct) for non-directory '$src'"
    else
      local maybe_dot="$([[ $_unhidden != true ]] && echo '.')"
      # if `_path` is empty, keep '', else append '/'
      local maybe_path="$([[ ! -z $_path ]] && echo "$_path/")"

      # relative path from home, w/ or w/o `.` based on `_unhidden`
      local dst="$HOME/${maybe_path}${maybe_dot}${_name}"

      link_file "$src" "$dst"
    fi
  fi
}

# applies given regex to given string, returning matches in `_regex_matches`
#
# calling function should define local `_regex_matches` that function saves into
# variable
#
# Args:
#   - {string} regex_to_apply - the regex to apply
#   - {string} input_to_apply_regex_to - input on which to apply regex
#
# Returns:
#   {string[]} _regex_matches - matches of the applied regex (either
#   `BASH_REMATCH` or `match` depending on your shell)
_apply_regex() {
  local regex_to_apply=$1 input_to_apply_regex_to=$2

  # not using for conditional, solely to populate match array
  [[ $input_to_apply_regex_to =~ $regex_to_apply ]]

  # outer parens, `(...)`, ensure copying as array, not string
  # TODO: more portable answer? currently defaulting to `BASH_REMATCH` if it
  # exists. `match` is `zsh` version of same environment variable
  _regex_matches=(${BASH_REMATCH[@]:-${match[@]}})
}

# extract target path relative to `~` at which to symlink
#
# described in more detail in the design doc (see top of this file for more)
#
# TODO: handle windows paths?
#
# Args:
#   - {string} filename - source file/directory name
#
# Returns:
#   {string} _path - extracted path (joined w/ `/`)
_extract_path() {
  local filename=$1
  # path capture group @ _regex_matches[1] (if _regex_matches length 2 or
  # greater)
  local _path_regex='^(([-._a-zA-Z]+~)*).*'
  _apply_regex $_path_regex $filename

  # _regex_matches will only have length >= 2 if capture groups triggered,
  # meaning we have path components
  if [ "${#_regex_matches[@]}" -ge 2 ]; then
    # split array on delimiter
    # `local IFS='<delimiter>' scopes any interference w/ `IFS`
    # `(<string>)` - parens trigger splitting `<string>` on `IFS` value
    # ref - https://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash#tab-top
    local IFS='~'
    # outer path capture group @ index 1 (index 0 holds entire matched string)
    path_components=(${_regex_matches[1]})

    # join array back w/ `join_by` function (return value saved in `_joined`)
    # `join_by` defined in $DOTFILES/setup/lib/util.sh
    local _joined=''
    join_by '/' "${path_components[@]}"
    _path=$_joined
  fi
}

# extract file/directory name from input
#
# described in more detail in the design doc (see top of this file for more)
#
# target name of file/directory to symlink
#
# Args:
#   - {string} filename - source file/directory name
#
# Returns:
#   {string} _name - extracted name
_extract_name() {
  local filename=$1

  # file/directory name capture group
  local _name_regex='~?([-._a-zA-Z]+)\.symlink.*$'
  _apply_regex $_name_regex $filename

  # outer path capture group @ index 1 (index 0 holds entire matched string)
  _name=${_regex_matches[1]}
}

# check flags set through filename
#
# described in more detail in the design doc (see top of this file for more)
#
# Flags (`.<flags>`) (can be specified in any order):
#   - `.d` (direct, return variable - `_direct`) - only valid for directories,
#     symlink whole folder w/ one symlink instead of recuresively traversing and
#     symlinking
#   - `._` (unhidden, return variable - `_unhidden`) - avoid prepending `.`
#
# Args:
#   - {string} filename - source file/directory name
#
# Returns:
#   {bool(s)} `_direct`, `_unhidden` - flags
_check_flags() {
  local filename=$1

  # flags capture group @ _regex_matches[1] (if _regex_matches length 2)
  local _flags_regex='^.*\.symlink(\.[_d]{1,2})?$'
  _apply_regex "$_flags_regex" "$filename"

  # _regex_matches will only have length 2 if capture groups triggered, meaning
  # we have flags
  if [ "${#_regex_matches[@]}" -eq 2 ]; then
    local _flags=${_regex_matches[1]}

    # check for substrings
    # if `d` & `_` in `_flags`
    # ref - https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash
    [[ $_flags == *"d"* ]] && { _direct=true; }
    [[ $_flags == *"_"* ]] && { _unhidden=true; }
  fi
}

# link single file between `src` & `dst`
#
# takes user input (potentially modified by `<option>_all` flags defined in
# calling scope)
#
# Args:
#   - {string} src - source path
#   - {string} dst - target path
#   - {string} [indentation_level=0] - level of indentation to print to
#       (Default: 0)
link_file() {
  # parameters
  local src=$1 dst=$2 indentation_level=${3:-0}

  # flags set by user interaction
  local overwrite= backup= skip= action=

  if [ -f "$dst" -o -d "$dst" -o -L "$dst" ]; then
    if [ "$overwrite_all" == "false" ] \
      && [ "$backup_all" == "false" ] \
      && [ "$skip_all" == "false" ]
    then
      local current_src="$(readlink "$dst")"

      if [ "$current_src" == "$src" ]; then
        skip=true
      else
        user "file exists: $dst ($(basename "$src")), what do you want to do?\n\
\t[s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?"
        read -n 1 action

        case "$action" in
          o )
            overwrite=true;;
          O )
            overwrite_all=true;;
          b )
            backup=true;;
          B )
            backup_all=true;;
          s )
            skip=true;;
          S )
            skip_all=true;;
          * )
            ;;
        esac
      fi
    fi

    overwrite=${overwrite:-$overwrite_all}
    backup=${backup:-$backup_all}
    skip=${skip:-$skip_all}

    if [ "$overwrite" == true ]; then
      rm -rf "$dst"
      success "removed $dst"
    fi

    if [ "$backup" == true ]; then
      mv "$dst" "${dst}.backup"
      success "moved $dst to ${dst}.backup"
    fi

    [ "$skip" == true ] && success "skipped $src"
  fi

  # "false" or empty
  if [ "$skip" != true ]; then
    ln -s "$src" "$dst"
    success "linked $src to $dst"
  fi
}

symlink
