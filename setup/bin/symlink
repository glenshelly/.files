#! /usr/bin/env bash

# <<<< motivation/design doc >>>>
# see writeup of motivation & methodology @ $DOTFILES/setup/symlink.md

source $DOTFILES/setup/lib/prompts.sh
source $DOTFILES/setup/lib/util.sh


symlink () {
  info "symlinking dotfiles according to scheme in $DOTFILES/setup/bin/symlink"

  local overwrite_all=false backup_all=false skip_all=false

  # write all files ending in .symlink
  for src in \
    $(find -H "$DOTFILES" -maxdepth 2 -name '*.symlink*' -not -path '*.git*')
  do
    filename=$(basename $src)

    local path_components='([-._a-zA-Z]+~)*';
    local name='[-._a-zA-Z]+';
    local flags='[_d]{1,2}';
    local _symlink_regex="^($path_components)($name)\.symlink(\.$flags)?$";

    [[ $filename =~ $_symlink_regex ]] && {
      echo "valid - $filename"
      header 'Symlinking'
      _symlink_based_on_filename $filename $src
    } || {
      info "skipped symlinking file w/ invalid syntax - $filename";
    }
  done
}

check_regex() {
  local path_components='([-._a-zA-Z]+~)*';
  local name='[-._a-zA-Z]+';
  local flags='[_d]{1,2}';
  local _symlink_regex="^($path_components)($name)\.symlink(\.$flags)?$";

  filename=$(basename $1)
  [[ $filename =~ $_symlink_regex ]] && {
    echo "valid - $filename"
    _symlink_based_on_filename $filename $1
  } || {
    info "skipped symlinking file w/ invalid syntax - $filename";
  }
}

_symlink_based_on_filename() {
  local filename=$1 src=$2
  local _path="" _name="" _direct=false _hidden=false

  # extracts destination name and optional path from target filename
  _extract_path
  _extract_name

  echo "path: $_path"
  echo "name: $_name"

  # extracts and checks values of each possible flag
  _check_flags
  echo "direct: $_direct"
  echo "hidden: $_hidden"

  # check if `src` is a directory
  # ref - https://www.tldp.org/LDP/abs/html/fto.html
  echo $src
  if [[ -d $src ]]; then
    echo 'directory!'
  else
    echo 'file!'
    if $_direct; then
      warn 'Invalid flag'
    else
      # dst="$HOME/.$(basename "${src%.*}")"
      link_file $src "$HOME/.$(basename "${src%.*}")"
    fi
  fi
}

# regex to apply in `$1`, string to apply to in `$2`
# save/return in `_regex_matches`
_apply_regex() {
  # not using for conditional, solely to populate match array
  [[ $2 =~ $1 ]]

  # outer parens, `(...)`, ensure copying as array, not string
  # TODO: more portable answer? currently defaulting to `BASH_REMATCH` if it
  # exists. `match` is `zsh` version of same environment variable
  _regex_matches=(${BASH_REMATCH[@]:-${match[@]}})
}

_extract_path() {
  # path capture group @ _regex_matches[1] (if _regex_matches length 2 or
  # greater)
  local _path_regex='^(([-._a-zA-Z]+~)*).*'
  _apply_regex $_path_regex $filename

  # _regex_matches will only have length >= 2 if capture groups triggered,
  # meaning we have path components
  if [ "${#_regex_matches[@]}" -ge 2 ]; then
    # split array on delimiter
    # `local IFS='<delimiter>' scopes any interference w/ `IFS`
    # `(<string>)` - parens trigger splitting `<string>` on `IFS` value
    # ref - https://stackoverflow.com/questions/918886/how-do-i-split-a-string-on-a-delimiter-in-bash#tab-top
    local IFS='~';
    # outer path capture group @ index 1 (index 0 holds entire matched string)
    path_components=(${_regex_matches[1]})

    # join array back w/ `join_by` function (return value saved in `_joined`)
    # `join_by` defined in $DOTFILES/setup/lib/util.sh
    local _joined=""
    join_by '/' "${path_components[@]}"
    _path=$_joined
  fi
}

_extract_name() {
  # file/directory name capture group
  local _name_regex='~?([-._a-zA-Z]+)\.symlink.*$';
  _apply_regex $_name_regex $filename

  # not using for conditional, solely to populate match array
  [[ $filename =~ $_name_regex ]];
  # outer parens, `(...)`, ensure copying as array, not string
  local _regex_matches=(${BASH_REMATCH[@]:-${match[@]}});

  # outer path capture group @ index 1 (index 0 holds entire matched string)
  _name=${_regex_matches[1]};
}

_check_flags() {
  # flags capture group @ _regex_matches[1] (if _regex_matches length 2)
  local _flags_regex='^.*\.symlink(\.[_d]{1,2})?$';
  _apply_regex $_flags_regex $filename

  # _regex_matches will only have length 2 if capture groups triggered, meaning
  # we have flags
  if [ "${#_regex_matches[@]}" -eq 2 ]; then
    local _flags=${_regex_matches[1]};

    # check for substrings
    # if `d` & `_` in `_flags`
    # ref - https://stackoverflow.com/questions/229551/how-to-check-if-a-string-contains-a-substring-in-bash
    [[ $_flags == *"d"* ]] && { _direct=true; }
    [[ $_flags == *"_"* ]] && { _hidden=true; };
  fi
}

# link single file between `src` & `dst`
# takes user input (potentially modified by `<option>_all` flags defined in
# calling scope)
#
# Args:
#   - src - source path
#   - dst - destination path
link_file () {
  local src=$1 dst=$2

  local overwrite= backup= skip=
  local action=

  if [ -f "$dst" -o -d "$dst" -o -L "$dst" ]
  then

    if [ "$overwrite_all" == "false" ] && [ "$backup_all" == "false" ] && [ "$skip_all" == "false" ]
    then

      local currentSrc="$(readlink $dst)"

      if [ "$currentSrc" == "$src" ]
      then

        skip=true;

      else

        user "File already exists: $dst ($(basename "$src")), what do you want to do?\n\
        [s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?"
        read -n 1 action

        case "$action" in
          o )
            overwrite=true;;
          O )
            overwrite_all=true;;
          b )
            backup=true;;
          B )
            backup_all=true;;
          s )
            skip=true;;
          S )
            skip_all=true;;
          * )
            ;;
        esac

      fi

    fi

    overwrite=${overwrite:-$overwrite_all}
    backup=${backup:-$backup_all}
    skip=${skip:-$skip_all}

    if [ "$overwrite" == "true" ]
    then
      rm -rf "$dst"
      success "removed $dst"
    fi

    if [ "$backup" == "true" ]
    then
      mv "$dst" "${dst}.backup"
      success "moved $dst to ${dst}.backup"
    fi

    if [ "$skip" == "true" ]
    then
      success "skipped $src"
    fi
  fi

  if [ "$skip" != "true" ]  # "false" or empty
  then
    ln -s "$1" "$2"
    success "linked $1 to $2"
  fi
}

# TODO: remove this
# echo 'remove me'
# check_regex $DOTFILES/config/one-one~two.two~file-name.extension.symlink.d
symlink
